'use strict';

const {inspect} = require('util');
const {join, resolve} = require('path');
const {mkdtemp, stat} = require('fs');
const osTmpdir = require('os').tmpdir;

const downloadPurescriptSource = require('download-purescript-source');
const feint = require('feint');
const gracefulFs = require('graceful-fs');
const inspectWithKind = require('inspect-with-kind');
const isPlainObj = require('is-plain-obj');
const minimist = require('minimist');
const mkdirp = require('mkdirp');
const Observable = require('zen-observable');
const once = require('once');
const rimraf = require('rimraf');
const spawnStack = require('spawn-stack');

const DIR_ERROR = 'Expected a path where the PureScript binary should be built (string)';
const SOURCE_DIR_ERROR = 'Expected `sourceDir` option to be a path where PureScript source files are temporally downloaded';
const ARGS_ERROR = 'Expected `args` option to be an array of user defined arguments passed to `stack setup` and `stack install`';

const buildOnlyArgs = new Set([
	'--dry-run',
	'--pedantic',
	'--fast',
	'--only-snapshot',
	'--only-dependencies',
	'--only-configure',
	'--trace',
	'--profile',
	'--no-strip',
	'--coverage',
	'--no-run-tests',
	'--no-run-benchmarks'
]);

const negligibleLineRe = /^WARNING: (?:filepath wildcard|(?:File|Directory) listed|Installation path|Specified pattern) .*/i;

module.exports = function buildPurescript(...args) {
	return new Observable(observer => {
		const argLen = args.length;

		if (argLen !== 1 && argLen !== 2) {
			throw new RangeError(`Expected 1 or 2 arguments (<string>[, <Object>]), but got ${
				argLen === 0 ? 'no' : argLen
			} arguments.`);
		}

		const [dir, options = {}] = args;

		if (typeof dir !== 'string') {
			throw new TypeError(`${DIR_ERROR}, but got a non-string value ${inspect(dir)}.`);
		}

		if (dir.length === 0) {
			throw new TypeError(`${DIR_ERROR}, but got '' (empty string).`);
		}

		if (argLen === 2) {
			if (!isPlainObj(options)) {
				throw new TypeError(`Expected build-purescript option to be an object, but got ${
					inspectWithKind(options)
				}.`);
			}

			if (options.sourceDir !== undefined) {
				if (typeof options.sourceDir !== 'string') {
					throw new TypeError(`${SOURCE_DIR_ERROR}, but got a non-string value ${
						inspectWithKind(options.sourceDir)
					}.`);
				}

				if (options.sourceDir.length === 0) {
					throw new Error(`${SOURCE_DIR_ERROR}, but got '' (empty string).`);
				}
			}

			if (options.cwd !== undefined) {
				throw new Error(`build-purescript doesn't support \`cwd\` option, but ${
					inspectWithKind(options.cwd)
				} was provided.`);
			}

			if (options.args !== undefined) {
				if (!Array.isArray(options.args)) {
					throw new TypeError(`${ARGS_ERROR}, but got a non-array value ${
						inspectWithKind(options.args)
					}.`);
				}
			}

			// to validate download-purescript-source arguments beforehand
			downloadPurescriptSource(__filename, options).subscribe({
				error(err) {
					observer.error(err);
				}
			}).unsubscribe();
		}

		const subscriptions = new Set();
		const installArgs = [
			'install',
			`--local-bin-path=${resolve(dir)}`,
			'--flag=purescript:RELEASE'
		];
		const defaultArgs = options.args ? options.args.filter(arg => {
			if (buildOnlyArgs.has(arg)) {
				installArgs.push(arg);
				return false;
			}

			return true;
		}) : [];
		const flags = Object.keys(minimist(defaultArgs), {
			alias: {
				j: ['jobs']
			}
		});

		if (flags.indexOf('local-bin-path') !== -1) {
			throw new Error('`--local-bin-path` flag is passed to the `stack` command, but it will be automatically set and cannot be modified via the flag.');
		}

		const spawnOptions = Object.assign({
			cwd: options.sourceDir ? resolve(options.sourceDir) : null
		}, options);

		const cleanupSourceDir = cb => spawnOptions.cwd ? rimraf(spawnOptions.cwd, {glob: false}, cb) : cb();
		let createdDir;

		const sendError = once((err, id) => {
			Object.defineProperty(err, 'id', {
				value: id,
				configurable: true,
				writable: true
			});

			if (createdDir) {
				rimraf(createdDir, {glob: false}, () => cleanupSourceDir(() => observer.error(err)));
				return;
			}

			cleanupSourceDir(() => observer.error(err));
		});

		const setupArgs = defaultArgs.concat(['setup']);
		const setupCommand = `stack ${setupArgs.join(' ')}`;

		const buildArgs = defaultArgs.concat(installArgs);
		const buildCommand = `stack ${buildArgs.join(' ')}`;

		const startBuildOnReady = feint(() => {
			subscriptions.add(Observable.from(spawnStack(buildArgs, spawnOptions)).subscribe({
				next(line) {
					if (negligibleLineRe.test(line)) {
						return;
					}

					observer.next({
						id: 'build',
						command: buildCommand,
						output: line
					});
				},
				error(err) {
					const negligibleMultiLineRe = new RegExp(`${negligibleLineRe.source}\\n\\r?`, 'gim');

					err.message = err.message.replace(negligibleMultiLineRe, '');
					err.stack = err.stack.replace(negligibleMultiLineRe, '');

					sendError(err, 'build');
				},
				complete() {
					cleanupSourceDir(() => {
						observer.next({id: 'build:complete'});
						observer.complete();
					});
				}
			}));
		});

		const setup = once(() => {
			mkdirp(dir, {fs: gracefulFs}, (mkdirErr, firstDir) => {
				if (mkdirErr) {
					sendError(mkdirErr, 'setup');
					return;
				}

				if (firstDir) {
					createdDir = firstDir;
				}

				subscriptions.add(Observable.from(spawnStack(setupArgs, spawnOptions))
				.subscribe({
					next(line) {
						observer.next({
							id: 'setup',
							command: setupCommand,
							output: line
						});
					},
					error(err) {
						sendError(err, 'setup');
					},
					complete() {
						observer.next({id: 'setup:complete'});
						startBuildOnReady();
					}
				}));
			});
		});

		function downloadPurescriptSourceTo(finalSourceDir) {
			const download = downloadPurescriptSource(finalSourceDir, options)
			.subscribe({
				next(progress) {
					progress.id = 'download';
					observer.next(progress);

					const {entry} = progress;

					if (entry.header.name === 'stack.yaml' && entry.bytes === entry.header.size) {
						setup();
					}
				},
				error(err) {
					sendError(err, 'download');
				},
				complete() {
					setup();
					observer.next({id: 'download:complete'});
					startBuildOnReady();
				}
			});

			subscriptions.add(download);
		}

		if (spawnOptions.cwd) {
			stat(spawnOptions.cwd, (err, sourceDirStat) => {
				if (observer.closed) {
					return;
				}

				if (err) {
					downloadPurescriptSourceTo(spawnOptions.cwd);
					return;
				}

				if (sourceDirStat.isDirectory()) {
					downloadPurescriptSourceTo(spawnOptions.cwd);
					spawnOptions.cwd = null;
					return;
				}

				const error = new Error(`Tried to download PureScript source to ${
					spawnOptions.cwd
				}, but a file already exits there.`);
				error.code = 'EEXIST';
				error.syscall = 'mkdir';
				error.path = spawnOptions.cwd;

				spawnOptions.cwd = null;
				sendError(error, 'download');
			});
		} else {
			mkdtemp(join(osTmpdir(), 'node-purescript-'), (err, tmpDir) => {
				if (observer.closed) {
					cleanupSourceDir(() => {});
					return;
				}

				if (err) {
					sendError(err, 'download');
					return;
				}

				spawnOptions.cwd = tmpDir;
				downloadPurescriptSourceTo(tmpDir);
			});
		}

		return function cancelBuild() {
			for (const subscription of subscriptions) {
				subscription.unsubscribe();
			}
		};
	});
};

Object.defineProperty(module.exports, 'supportedBuildFlags', {
	value: buildOnlyArgs,
	enumerable: true
});
