'use strict';

const {join, resolve} = require('path');
const {createGunzip, createGzip} = require('zlib');

const truncatedList = require('truncated-list');
const appCacheDir = require('app-cache-dir');
const arch = require('arch');
const downloadOrBuildPurescript = require('download-or-build-purescript');
const execa = require('execa');
const fileToTar = require('file-to-tar');
const inspectWithKind = require('inspect-with-kind');
const isPlainObj = require('is-plain-obj');
const once = require('once');
const Observable = require('zen-observable');
const prepareWrite = require('prepare-write');
const readdirClean = require('readdir-clean');
const rimraf = require('rimraf');
const tarToFile = require('tar-to-file');
const tildePath = require('tilde-path');

function addId(obj, id) {
	Object.defineProperty(obj, 'id', {
		value: id,
		writable: true
	});

	return obj;
}

const CACHE_DIR_NAME = 'npm';
const CACHE_DIR_ERROR = 'Expected `cacheDir` option to be a valid directory path (string) or `false` to disable cache';
const MAX_LIST_NUM = 4;

module.exports = function installPurescript(...args) {
	return new Observable(observer => {
		const argLen = args.length;

		if (argLen !== 1 && argLen !== 2) {
			throw new RangeError(`Exepcted 1 or 2 arguments (<string>[, <Object>]), but got ${
				argLen === 0 ? 'no' : argLen
			} arguments.`);
		}

		const [dir, options = {}] = args;

		if (args.length === 2) {
			if (!isPlainObj(options)) {
				throw new TypeError(`Expected an object to set install-purescript options, but got ${
					inspectWithKind(options)
				}.`);
			}

			if (options.cacheDir !== undefined && options.cacheDir !== false) {
				if (typeof options.cacheDir !== 'string') {
					throw new TypeError(`${CACHE_DIR_ERROR}, but got ${inspectWithKind(options.cacheDir)}.`);
				}

				if (options.cacheDir.length === 0) {
					throw new Error(`${CACHE_DIR_ERROR.replace(' (string)', '')}, but got '' (empty string).`);
				}
			}

			if (options.forceReinstall === true) {
				if (options.cacheDir === false) {
					throw new Error('`forceReinstall` option cannot be enabled when `cacheDir` option is `false`.');
				}
			} else if (options.forceReinstall !== undefined && options.forceReinstall !== false) {
				throw new TypeError(`Expected \`forceReinstall\` option to be a Boolean value, but got ${
					inspectWithKind(options.forceReinstall)
				}.`);
			}
		}

		const subscriptions = new Set();

		function cancelInstallation() {
			for (const subscription of subscriptions) {
				subscription.unsubscribe();
			}
		}

		if (typeof dir !== 'string' || dir.length === 0 || options.cacheDir === false) {
			subscriptions.add(downloadOrBuildPurescript(dir, options).subscribe({
				next(val) {
					observer.next(val);
				},
				error(err) {
					observer.error(err);
				},
				complete(path) {
					observer.complete({
						path,
						cachePath: null
					});
				}
			}));

			return cancelInstallation;
		}

		// to validate download-or-build-purescript arguments beforehand
		downloadOrBuildPurescript(__filename, options).subscribe({
			error(err) {
				observer.error(err);
			}
		}).unsubscribe();

		const platform = options.platform || process.platform;
		const defaultBinName = `purs${platform === 'win32' ? '.exe' : ''}`;
		const binName = typeof options.rename === 'function' ? `${options.rename(defaultBinName)}` : defaultBinName;
		const binPath = resolve(dir, binName);

		const cacheDir = options.cacheDir ? options.cacheDir : join(appCacheDir('purescript'), CACHE_DIR_NAME);
		const cachePath = join(
			cacheDir,
			`v${options.version || downloadOrBuildPurescript.defaultVersion}-${platform}-${arch()}.tgz`
		);

		function removeBrokenCache() {
			rimraf(cachePath, {disableGlob: true}, () => {});
		}

		function complete(pathOverride, cachePathOverride) {
			observer.complete({
				path: pathOverride || binPath,
				cachePath: cachePathOverride || null
			});
		}

		function main() {
			subscriptions.add(downloadOrBuildPurescript(dir, options).subscribe({
				next(val) {
					observer.next(val);
				},
				error(err) {
					observer.error(err);
				},
				complete(path) {
					subscriptions.add(fileToTar(path, cachePath, {
						map(header) {
							header.name = defaultBinName;
							return header;
						},
						tarTransform: createGzip(),
						...options
					}).subscribe({
						next(val) {
							val.id = 'write-cache';
							observer.next(val);
						},
						error(err) {
							observer.next({
								id: 'write-cache:fail',
								error: addId(err, 'write-cache')
							});

							complete(path);
						},
						complete() {
							observer.next({id: 'write-cache:complete'});
							complete(path, cachePath);
						}
					}));
				}
			}));
		}

		if (options.forceReinstall) {
			main();
			return cancelInstallation;
		}

		const searchCacheValue = {
			id: 'search-cache',
			path: cachePath,
			found: false,
			warning: null
		};

		(async () => {
			try {
				const [cacheFilenames] = await Promise.all([readdirClean(cacheDir), prepareWrite(binPath)]);
				const cacheCount = cacheFilenames.length;

				if (observer.closed) {
					return;
				}

				const sendSearchCacheEvent = once(() => observer.next(searchCacheValue));

				if (cacheCount >= MAX_LIST_NUM) {
					searchCacheValue.warning = `The cache directory ${
						tildePath(cacheDir)
					} has ${cacheCount} contents, most of whom would be currently unused:

${truncatedList(cacheFilenames, MAX_LIST_NUM)}

You can free disk usage by deleting obsolete caches or simply removing the cache directory itself.`;
				}

				subscriptions.add(tarToFile(cachePath, binPath, {
					...options,
					map(header) {
						searchCacheValue.found = true;
						sendSearchCacheEvent();

						return header;
					},
					tarTransform: createGunzip()
				}).subscribe({
					next(val) {
						val.id = 'restore-cache';
						observer.next(val);
					},
					error(err) {
						sendSearchCacheEvent();

						if (!/^E(ISDIR|NOENT)$/.test(err.code)) {
							observer.next({
								id: 'restore-cache:fail',
								error: addId(err, 'restore-cache')
							});
						}

						removeBrokenCache();
						main();
					},
					async complete() {
						observer.next({id: 'restore-cache:complete'});

						if (options.platform && options.platform !== process.platform) {
							complete();
							return;
						}

						observer.next({id: 'check-binary'});

						try {
							await execa(binPath, ['--version'], options);
							observer.next({id: 'check-binary:complete'});
							complete();
						} catch (err) {
							observer.next({
								id: 'check-binary:fail',
								error: addId(err, 'check-binary')
							});

							removeBrokenCache();
							main();
						}
					}
				}));
			} catch (err) {
				if (observer.closed) {
					return;
				}

				observer.next(searchCacheValue);
				main();
			}
		})();

		return cancelInstallation;
	});
};

Object.defineProperty(module.exports, 'cacheDirName', {
	value: CACHE_DIR_NAME,
	enumerable: true
});

Object.defineProperty(module.exports, 'defaultVersion', {
	value: downloadOrBuildPurescript.defaultVersion,
	enumerable: true
});

Object.defineProperty(module.exports, 'supportedBuildFlags', {
	value: downloadOrBuildPurescript.supportedBuildFlags,
	enumerable: true
});
