#!/usr/bin/env node
'use strict';

const {resolve} = require('path');
const {inspect} = require('util');

const chalk = require('chalk');

const isPrettyMode = process.stdout && process.stdout.isTTY && !/^1|true$/i.test(process.env.CI);
chalk.enabled = chalk.enabled && isPrettyMode;

const installPurescript = require('install-purescript');
const logUpdate = require('log-update');
const logSymbols = require('log-symbols');
const minimist = require('minimist');
const ms = require('ms');
const neatFrame = require('neat-frame');
const neatStack = require('neat-stack');
const once = require('once');
const platformName = require('platform-name');
const SizeRate = require('size-rate');
const tildePath = require('tilde-path');
const ttyTruncate = require('tty-truncate');
const verticalMeter = require('vertical-meter');

const {blue, cyan, dim, magenta, red, strikethrough, underline, yellow} = chalk;

const error = `${logSymbols.error} `;
const info = isPrettyMode ? `${logSymbols.info} ` : '';
const success = `${logSymbols.success} `;
const warning = `${logSymbols.warning} `;

const stackArgs = [];

const originalArgv = process.argv.slice(2);
const argv = minimist(originalArgv, {
	alias: {
		c: 'cache',
		f: 'force',
		h: 'help',
		n: 'name',
		p: 'platform',
		v: 'version',
		V: 'purs-ver'
	},
	boolean: [
		'force',
		'help',
		'version'
	],
	string: [
		'_',
		'cache',
		'name',
		'platform',
		'purs-ver'
	],
	default: {
		cache: undefined,
		force: false,
		'purs-ver': installPurescript.defaultVersion
	},
	unknown(flag) {
		if (!installPurescript.supportedBuildFlags.has(flag)) {
			return;
		}

		stackArgs.push(flag);
	}
});

if (argv.help) {
	console.log(`install-purescript v${require('./package.json').version}
Install PureScript to a given directory

Usage:
install-purescript [options] [directory]

Example:
install-purescript .
install-purescript ./path/to/project

Options:
--purs-ver, -V <string> Specify PureScript version
                        Default: ${installPurescript.defaultVersion}
--cache,    -c <string> Specify cache directory
--no-cache              Don't create or write a cache
--force,    -f          Reinstall a binary regardless of whether a cache exists
--name,     -n <string> Change a binary name
                        Default: 'purs.exe' on Windows, 'purs' on others
                        Or, if the target directory contains package.json
                        with \`bin\` field specifying a path of \`purs\` command,
                        this option defaults to its value
--platform, -p <string> Download a binary for the specific platform
                        one of 'linux' 'darwin' and 'win32'
--help,     -h          Print usage information
--version,  -v          Print version

Also, these flags are passed to \`stack install\` command if provided:
${Array.from(installPurescript.supportedBuildFlags).join('\n')}
`);

	process.exit();
}

if (argv._.length > 1) {
	console.error(`Multiple paths specified: ${argv._.map(path => inspect(path)).join(', ')}
Pass a single directory path where you want to install PureScript.`);
	process.exit(1);
}

if (argv.version) {
	console.log(require('./package.json').version);
	process.exit();
}

if (argv._.length === 0) {
	console.error(`Specify a directory path where you want to install PureScript.
Run \`install-purescript --help\` to see more details.`);
	process.exit(1);
}

if (!argv.name) {
	try {
		const {purs} = require(resolve(argv._[0], 'package.json')).bin;

		if (purs) {
			argv.name = purs;
		}
	} catch (e) {} // eslint-disable-line no-empty
}

const platform = argv.platform !== undefined ? platformName.map.get(argv.platform) : platformName();

class TaskGroup extends Map {
	constructor(iterable) {
		super(iterable);

		if (argv.cache === false) {
			this.delete('write-cache');
		}

		if (argv.platform && argv.platform !== process.platform) {
			this.delete('check-binary');
		}

		const pairs = [...this.entries()];

		for (const [index, [_, task]] of pairs.entries()) {
			if (index < pairs.length - 1) {
				task.nextTask = pairs[index + 1][1];
			}
		}
	}
}

const taskGroups = [
	new TaskGroup([
		[
			'search-cache',
			{
				head: ''
			}
		]
	]),
	new TaskGroup([
		[
			'restore-cache',
			{
				head: `Restore the cached ${cyan(argv['purs-ver'])} binary${platform ? ` for ${platform}` : ''}`,
				byteFormatter: null
			}
		],
		[
			'check-binary',
			{
				head: 'Verify the restored binary works correctly'
			}
		]
	]),
	new TaskGroup([
		[
			'head',
			{
				head: `Check if a prebuilt ${cyan(argv['purs-ver'])} binary is provided${platform ? ` for ${platform}` : ''}`,
				status: 'processing'
			}
		],
		[
			'download-binary',
			{
				head: 'Download the prebuilt PureScript binary',
				byteFormatter: null
			}
		],
		[
			'check-binary',
			{
				head: 'Verify the prebuilt binary works correctly'
			}
		],
		[
			'write-cache',
			{
				head: 'Save the downloaded binary to the cache directory',
				allowFailure: true,
				byteFormatter: null
			}
		]
	]),
	new TaskGroup([
		[
			'check-stack',
			{
				head: 'Check if \'stack\' command is available',
				status: 'processing',
				noClear: true
			}
		],
		[
			'download-source',
			{
				head: `Download the PureScript ${cyan(argv['purs-ver'])} source`,
				status: 'processing',
				byteFormatter: null
			}
		],
		[
			'setup',
			{
				head: 'Ensure the appropriate GHC is installed'
			}
		],
		[
			'build',
			{
				head: 'Build a binary from source'
			}
		],
		[
			'write-cache',
			{
				head: 'Save the built binary to the cache directory',
				allowFailure: true,
				byteFormatter: null
			}
		]
	])
];

let time = Date.now();
let frame = 0;
let loop = 0;
let resolvePromise;

const spinnerFrames = [4, 18, 50, 49, 53, 45, 31, 32, 0, 8].map(code => String.fromCharCode(10247 + code));

const render = isPrettyMode ? () => {
	const lines = [];

	for (const {allowFailure, byteFormatter, duration, head, message, status, subhead} of taskGroups[0].values()) {
		if (status === 'done' || status === 'failed') {
			const durationStr = process.stdout.columns > head.length && duration >= 100 ? dim.gray(` (${ms(duration)})`) : '';

			if (status === 'done') {
				lines.push(ttyTruncate(`${success}${head}${durationStr}`));
			} else {
				lines.push(ttyTruncate(`${allowFailure ? warning : error}${head}${durationStr}`));
			}
		} else if (status === 'processing') {
			lines.push(ttyTruncate(`${yellow(spinnerFrames[Math.floor(frame)])} ${head}`));
		} else if (status === 'skipped') {
			lines.push(ttyTruncate(`${yellow('▬')} ${strikethrough(head)}`));
		} else {
			// Dimming 2 spaces is a workaround for https://github.com/chalk/wrap-ansi/issues/23
			// Change them to non-dimmed ones if the issue is resolved.
			lines.push(ttyTruncate(`${dim('  ')}${head}`));
		}

		if (subhead) {
			lines.push(ttyTruncate(dim(`  ${subhead}`)));
		}

		if (message) {
			if (status === 'failed') {
				lines.push(`${red(`  ${message.replace(/^[ \t]+/, '')}`)}`);
			} else {
				lines.push(ttyTruncate(dim(`  ${
					byteFormatter ? `⢸${verticalMeter(byteFormatter.bytes / byteFormatter.max)}⡇ ` : ''
				}${message}`)));
			}
		}
	}

	logUpdate(`${lines.join('\n')}\n`);
} : () => {
	for (const [taskName, {allowFailure, duration, message, status, head}] of taskGroups[0]) {
		if (status !== 'done' && status !== 'failed') {
			continue;
		}

		const durationStr = duration < 100 ? '' : ` (${ms(duration)})`;

		if (status === 'done') {
			console.log(`[ SUCCESS ] ${head}${durationStr}`);
		} else {
			console.log(`[ ${allowFailure ? 'WARNING' : 'FAILURE'} ] ${head}${durationStr}`);
			console.log(`${message}\n`);
		}

		taskGroups[0].delete(taskName);
	}
};

const initialize = once(firstEvent => {
	if (firstEvent.id === 'search-cache') {
		if (firstEvent.found) {
			console.log(`${info}Found a cache at ${magenta(tildePath(firstEvent.path))}\n`);
		}

		if (firstEvent.warning) {
			console.log(`${yellow((isPrettyMode ? neatFrame : str => str)(firstEvent.warning))}\n`);
		}
	}

	if (!isPrettyMode) {
		return;
	}

	loop = setInterval(() => {
		frame += 0.5;

		if (frame === spinnerFrames.length) {
			frame = 0;
		}

		render();
	}, 40);
});

const promise = new Promise(internalResolve => {
	resolvePromise = internalResolve;
});

function calcDuration(task) {
	const newTime = Date.now();

	task.duration = newTime - time;
	time = newTime;
}

function getCurrentTask(currentId) {
	while (!taskGroups[0].has(currentId)) {
		taskGroups.shift();
	}

	return taskGroups[0].get(currentId);
}

function showError(erroredTask, err) {
	const showLongMessage = isPrettyMode ? neatFrame : str => str.replace(/(\r?\n)+/g, ' ');
	erroredTask.status = 'failed';

	if (err.code === 'ERR_UNSUPPORTED_PLATFORM') {
		const firstLine = `Prebuilt PureScript binary is not provided for ${platform}.`;

		if (argv.platform !== undefined && argv.platform !== process.platform) {
			erroredTask.message = showLongMessage(firstLine);
		} else {
			erroredTask.message = showLongMessage(`${firstLine}

Although this program still tries to install PureScript by compiling the source code, it will take much, so much more time to finish than just downloading a prebuilt one.

To make installation faster on ${platform},

1. Open a new issue "Provide a prebuilt binary for ${platform}" on https://github.com/purescript/purescript/issues unless it already exists.
2. Help the community to fix the issue, for exmaple, discuss how to provide prebuilt binaries for ${platform} continuously.`);
		}
	} else if (err.code === 'ERR_UNKNOWN_PLATFORM') {
		erroredTask.message = showLongMessage(err.message);
	} else if (err.INSTALL_URL) {
		erroredTask.message = showLongMessage(`${'\'stack\' command is required for building PureScript from source, ' +
      'but it\'s not found in your PATH. Make sure you have installed Stack and try again.\n\n' +
      '→ '}${underline(err.INSTALL_URL)}`);
	} else {
		erroredTask.message = neatStack(err);
	}

	calcDuration(erroredTask);

	for (const task of taskGroups[0].values()) {
		if (task.status !== 'done' && task.status !== 'failed') {
			task.status = 'skipped';
		}
	}
}

installPurescript(argv._[0], {
	args: stackArgs,
	cacheDir: argv.cache,
	forceReinstall: argv.force,
	platform: argv.platform,
	rename: argv.name ? () => argv.name : undefined,
	version: argv['purs-ver'],
	headers: {
		'user-agent': 'install-purescript-cli (https://github.com/shinnn/install-purescript-cli)'
	}
}).subscribe({
	next(event) {
		initialize(event);

		const task = getCurrentTask(event.id.replace(/:.*$/, ''));

		if (event.id.endsWith(':fail')) {
			showError(task, event.error);
			render();

			if (task.allowFailure) {
				return;
			}

			if (isPrettyMode) {
				logUpdate.done();
			}

			taskGroups.shift();

			console.log(`${blue('↓')} ${
				taskGroups.length === 2 ?
					'Reinstall a binary since the cache is broken' :
					'Fallback: building from source'
			}\n`);

			return;
		}

		if (event.id.endsWith(':complete')) {
			task.status = 'done';
			calcDuration(task);

			if (!task.noClear) {
				task.subhead = '';
				task.message = '';
			}

			if (task.nextTask && !task.nextTask.status) {
				task.nextTask.status = 'processing';
			}

			render();
			return;
		}

		if (!isPrettyMode) {
			if (event.output !== undefined) {
				if (!task.subhead) {
					task.subhead = event.command;
					console.log(`[ RUNNING ] command: ${task.subhead}`);
				}

				console.log(`  ${event.output}`);
			}

			return;
		}

		if (event.output !== undefined) {
			task.status = 'processing';
			task.subhead = event.command;
			task.message = event.output;
		} else if (event.id === 'restore-cache' || event.id === 'write-cache') {
			task.status = 'processing';

			if (!task.byteFormatter) {
				task.byteFormatter = new SizeRate({max: event.header.size});
			}

			task.message = task.byteFormatter.format(event.bytes);
		} else if (event.id === 'download-binary') {
			task.subhead = event.response.url;
			task.status = 'processing';

			if (!task.byteFormatter) {
				task.byteFormatter = new SizeRate({max: event.entry.header.size});
			}

			task.message = task.byteFormatter.format(event.entry.bytes);
		} else if (event.id === 'download-source') {
			task.subhead = event.response.url;
			task.status = 'processing';

			if (event.entry.header.size !== 0) {
				task.byteFormatter = new SizeRate({max: event.entry.header.size});
				task.message = `${task.byteFormatter.format(event.entry.bytes)} → ${event.entry.header.name}`;
			}
		} else if (event.id === 'check-stack') {
			task.message = `${event.version} found at ${event.path}`;
		}
	},
	error(err) {
		clearInterval(loop);

		if (err.id) {
			const task = getCurrentTask(err.id);
			showError(task, err);
			render();
		} else {
			console.error(neatStack(err));
		}

		process.exit(1);
	},
	complete(paths) {
		render();
		clearInterval(loop);

		if (isPrettyMode) {
			logUpdate.done();
		} else {
			console.log();
		}

		console.log(`Installed to ${magenta(tildePath(paths.path))}`);

		if (paths.cachePath) {
			console.log(`Cached to ${magenta(tildePath(paths.cachePath))}`);
		}

		console.log();

		resolvePromise();
	}
});

module.exports = promise;
