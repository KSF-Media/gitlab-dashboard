'use strict';

const {extname, basename, join, sep} = require('path');

const dlTgz = require('dl-tgz');
const inspectWithKind = require('inspect-with-kind');
const isPlainObj = require('is-plain-obj');
const Observable = require('zen-observable');

const ignoredExtensions = new Set([
	'.md',
	'.yml'
]);

const ignoredDirectoryNames = [
	'appveyor',
	'examples',
	'psc-bundle',
	'psc-ide',
	'scripts',
	'travis'
];

const ignoredFilenames = new Set([
	'.gitignore',
	'logo.png',
	'make_release_notes'
]);

const BASE_URL = 'https://github.com/purescript/purescript/archive/';
const DEFAULT_REV = 'v0.12.0-rc1';

const REV_ERROR = `Expected \`revision\` option to be a string of PureScript version or commit hash, for exmaple '${DEFAULT_REV}' and 'ee2fcf'`;

module.exports = function downloadPurescriptSource(...args) {
	const argLen = args.length;

	if (argLen !== 1 && argLen !== 2) {
		return new Observable(observer => {
			observer.error(new RangeError(`Expected 1 or 2 arguments (<string>[, <Object>]), but got ${
				argLen === 0 ? 'no' : argLen
			} arguments.`));
		});
	}

	const [dir, options] = args;

	if (typeof dir !== 'string') {
		return new Observable(observer => {
			observer.error(new TypeError(`Expected a directory path where PureScript source will be extracted, but got a non-string value ${
				inspectWithKind(dir)
			}.`));
		});
	}

	const defaultOptions = {
		ignore(filePath, header) {
			if (ignoredExtensions.has(extname(header.name))) {
				return true;
			}

			const [topLevelDir] = header.name.split(sep);

			for (const ignoredDir of ignoredDirectoryNames) {
				if (header.name.startsWith(join(topLevelDir, ignoredDir))) {
					return true;
				}
			}

			return ignoredFilenames.has(basename(header.name));
		},
		baseUrl: BASE_URL
	};

	if (argLen === 1) {
		return dlTgz(`${DEFAULT_REV}.tar.gz`, dir, defaultOptions);
	}

	if (!isPlainObj(options)) {
		return new Observable(observer => {
			observer.error(new TypeError(`Expected download-purescript-source option to be an object, but got ${
				inspectWithKind(options)
			}.`));
		});
	}

	const rev = options.revision;

	if (rev !== undefined) {
		if (typeof rev !== 'string') {
			return new Observable(observer => {
				observer.error(new TypeError(`${REV_ERROR}, but got a non-string value ${inspectWithKind(rev)}.`));
			});
		}

		if (rev.length === 0) {
			return new Observable(observer => {
				observer.error(new Error(`${REV_ERROR}, but got '' (empty string).`));
			});
		}
	}

	if (options.strip !== undefined && options.strip !== 1) {
		return new Observable(observer => {
			observer.error(new Error(`\`strip\` option is unchangeable, but ${
				inspectWithKind(options.strip)
			} was provided.`));
		});
	}

	return dlTgz(`${rev || DEFAULT_REV}.tar.gz`, dir, Object.assign(defaultOptions, options));
};

Object.defineProperty(module.exports, 'defaultRevision', {
	value: DEFAULT_REV,
	enumerable: true
});

